% !TeX encoding = windows-1250

\chapter{Mo¿liwe metody optymalizacji podczas produkcji modeli oraz tekstur}
\label{t:optimalizations}
Celem tego rozdzia³u jest przedstawienie istniej¹cych i wykorzystywanych w bran¿y gier komputerowych metod optymalizacji assetów trójwymiarowych. Ka¿da z opisywanych metod zawiera opis, potencjalne zyski id¹ce za jej zastosowaniem oraz przyk³ad u¿ycia w istniej¹cych produkcjach.

\section{Modularnoœæ modeli i tekstur}
Wykorzystywanie modu³ów przy tworzenia poziomów w grach komputerowych jest technik¹ bardzo szeroko stosowan¹ przez wspó³czesnych twórców. Ciê¿ko jest obecnie znaleŸæ produkcjê która nie korzysta³aby z zalet modularnoœci. \newline

Czym jest wspomniany proces? Jedna z najwiêkszych firm bran¿ komputerowej - Epic Games - definiuje go jako ''tworzenie du¿ej liczby wysokojakoœciowych fragmentów poziomu i wielokrotne u¿ywanie ich w inteligentny sposób''\cite{Investigation}. W praktyce wygl¹da to tak, ¿e wszelkie modele oraz tekstury tworzone s¹ tak, aby mo¿liwe by³o u³o¿enie jak najwiêkszej liczby kombinacji pasuj¹cych do siebie elementów. Dziêki temu ze stosunkowo niewielkiej liczby modu³ów, osoba zajmuj¹ca siê póŸniej kreacj¹ docelowych poziomów w silniku gry mo¿e doœæ niskim kosztem bardzo uatrakcyjniæ ich wygl¹d. Rodzi to jednak wiele wyzwañ przed artystami zajmuj¹cymi siê tworzeniem siatek wielok¹towych oraz rysowaniem i edycj¹ tekstur. Przyk³adem jest tu chocia¿by odpowiednia konfiguracja siatki wed³ug której uk³adane s¹ elementy w silniku (ang. grid).\cite{CreatingModularGameArt} Wiêcej o nich wspomnê w kolejnym rozdziale, w którym opiszê szczegó³y procesu twórczego. \newline

Bardzo wa¿nym pojêciem, które czêsto przewija siê przy okazji takiego podejœcia do procesu twórczego jest ''tiling'' (ang. tile - kafelek). W przypadku trójwymiarowych siatek wielok¹towych odnosi siê ono do tworzenia ich w taki sposób, aby postawione obok siebie dwa obiekty (na przyk³ad fragmenty œciany) wygl¹da³y jak jeden, spójny model. Analogicznie jest w przypadku tekstur - gdy u³o¿ymy taki obrazek obok siebie kilka razy, osoba ogl¹daj¹ca go nie mo¿e byæ w stanie zauwa¿yæ ³¹czeñ miêdzy instancjami (ale mo¿e spostrzec powtarzalnoœæ, jeœli powielimy go zbyt wiele razy). \newline Ponadto wyró¿niamy 2 rodzaje tilingu: 
\begin{itemize}
	\item jednokierunkowy - model lub tekstura mo¿e byæ uk³adana tylko w poziomie lub w pionie bez zauwa¿alnych szwów 
	\item dwukierunkowy - uk³adanie bez szwów jest mo¿liwe zarówno w poziomie, jak i w pionie
\end{itemize}
 Przyk³ady obiektów pierwszego i drugiego rodzaju znajdziemy na rysunkach 2.1 oraz 2.2.
 \begin{figure}[!ht]
 	\centering
 	\includegraphics[scale = 0.85]{figures/Wall_tileable}
 	\caption{Przyk³ad trójwymiarowego modelu (œciany) z jednokierunkowym tilingiem (Ÿród³o: opracowanie w³asne)}
 \end{figure}
 \begin{figure}[!ht]
 	\centering
 	\includegraphics[scale = 0.65]{figures/Floor_wooden_2}
 	\caption{Przyk³ad tekstury (pod³ogi) z dwukierunkowym tilingiem (Ÿród³o: opracowanie w³asne)}
 \end{figure}
 \newpage
 Mo¿emy wyró¿niæ dwa rodzaje zalet, które niesie za sob¹ modularne podejœcie do procesu tworzenia poziomów. Pierwsze z nich, to potencjalne korzyœci dla samego procesu. Przyk³adem tutaj s¹ miêdzy innymi:
 \begin{itemize}
 	\item W wiêkszoœci przypadków pozwala na skrócenie czasu potrzebnego na stworzenie poziomu, co pozwala na lepsze dopracowanie samych assetów.
 	\item Mo¿liwoœæ wprowadzania poprawek na elementach ju¿ u³o¿onych w docelowym silniku (pod warunkiem odpowiedniego zaprojektowania ich wczeœniej). Dziêki temu ludzie zajmuj¹cy siê projektowaniem poziomów do gier mog¹ rozpocz¹æ ich uk³adanie w silniku na bardzo wczesnym etapie produkcji. Przy odpowiednim ustawieniu punktu odniesienia w przestrzeni dla obiektów (ang. pivot point), obiekty mog¹ byæ ustawione w docelowym po³o¿eniu ju¿ na etapie wczesnych prototypów, by po jakimœ czasie zostaæ podmienione na finalne modele z teksturami bez dodatkowej ingerencji w pliki sceny.
 	\item Wielokrotne wykorzystanie tych samych modeli i tekstur wcale nie oznacza, ¿e poziomy w grze bêd¹ wygl¹da³y na nudne i powtarzalne. Przy odpowiednim wykorzystaniu oœwietlenia, projektanci s¹ w stanie uzyskiwaæ bardzo ciekawe efekty bez potrzeby tworzenia wielu assetów. T¹ sytuacjê mo¿emy zaobserwowaæ na rysunku 2.3, gdzie porównano ten sam fragment sceny przy ró¿nych ustawieniach oœwietlenia.
  	\begin{figure}[!ht]
 		\centering
  		\includegraphics[scale = 0.20]{figures/Using_light_to_differ_assets}
  		\caption{Wykorzystanie oœwietlenia w celu ukrycia faktu wykorzystania niewielkiej iloœci modeli (Ÿród³o: \cite{Investigation})}
 	\end{figure}
 \end{itemize}
 Dodatkowo, modularnoœæ pozwala na uzyskanie profitów w kwestii wydajnoœci projektu. To w du¿ej mierze z tego powodu zyska³a ona tak du¿¹ popularnoœæ wœród twórców gier komputerowych, gdy¿ dla uzyskania maksymalnego komfortu rozgrywki nale¿y jak najbardziej skróciæ czas renderingu pojedynczej klatki obrazu. \newline
 
 Pierwszym z nich jest potencjalna oszczêdnoœæ pamiêci karty graficznej. Jak to siê dzieje, ¿e mo¿emy uzyskaæ taki efekt? Otó¿, gdy chcemy by karta graficzna wyrenderowa³a nam klatkê obrazu, musimy najpierw zapewniæ jej wszystkie potrzebne do tego dane. Wœród nich znajdziemy chocia¿by: orientacjê w przestrzeni obiektów (oraz wierzcho³ków tych¿e obiektów), koordynaty teksturowania, pozycje œwiate³ oraz same tekstury. Wszystkie one musz¹ zostaæ skopiowane do wewnêtrznej pamiêci RAM karty graficznej. Jeœli scena bêdzie sk³adaæ siê z jednego, wielkiego modelu 3d, to bêdzie on musia³ byæ w ca³oœci wczytany do pamiêci w celu jego dalszego wykorzystania w procesie renderingu. Stworzenie modu³ów, które nastêpnie zostaj¹ wielokrotnie instancjonowane w scenie pozwala na nieco inne potraktowanie danych przesy³anych do karty. Sam model zostaje skopiowany do pamiêci tylko raz, a dane dotycz¹ce transformacji ka¿dej z instancji (pozycji, rotacji i skali) s¹ przesy³ane niezale¿nie od nich. Pozwala to na potencjalne oszczêdnoœci w szczególnoœci, gdy wielokrotnie wykorzystujemy dany modu³. \cite{GPUGems2} \newline
 
 Kolejnym argumentem przemawiaj¹cym za stosowaniem modu³ów jest zwiêkszenie przenoœnoœci i uniwersalnoœci samych assetów. Analogicznie do poprzedniego przyk³adu - je¿eli scena zosta³a stworzona jako jeden, wielki model to aby stworzyæ nieco zmienion¹ jej wersjê nale¿y skopiowaæ ca³oœæ, wprowadziæ zmiany, a na koniec wyeksportowaæ now¹ wersjê (równie¿ jako jeden, du¿y obiekt). Stwarza to przynajmniej trzy problemy:
 \begin{itemize}
 	\item Ka¿da zmiana uk³adu sceny wymaga ingerencji w pliki Ÿród³owe modeli 3d oraz ich ponowny eksport do silnika.
 	\item Nie jest mo¿liwe ponowne wykorzystanie w prosty sposób fragmentów sceny w innych projektach lub nawet w tym samym projekcie i kolejnych poziomach. Ka¿dorazowe wykorzystanie elementów modelu wymaga ingerencji w pliki Ÿród³owe oraz wyodrêbnienie ich od reszty siatki.
 	\item Wspomniana ju¿ wczeœniej pamiêæ karty graficznej zostaje niepotrzebnie zapisana nadmiarowymi danymi, które mog³yby zostaæ zast¹pione instancjonowaniem.
 \end{itemize}
 Wszystkie trzy problemy eliminuje zaprojektowanie i stworzenie modu³ów, z których dopiero póŸniej s¹ budowane docelowe poziomy w zale¿noœci od aktualnych potrzeb projektanta. Dodatkowo pozwala równie¿ na doœæ wygodne oddzielenie pracy projektanta poziomów od artysty tworz¹cego modele i tekstury.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale = 0.20]{figures/AssetsPack}
	\caption{Przyk³adowa paczka modularnych modeli (Ÿród³o: \cite{ModularPack})}
\end{figure}
\section{Atlasowanie}
Atlasowanie jest procesem maj¹cym na celu zebranie wielu niekoniecznie powi¹zanych ze sob¹ assetów w jedn¹ ca³oœæ oraz przechowywanie ich w jednym, du¿ym pliku. Mo¿liwe jest stosowanie go zarówno w odniesieniu do siatek wielok¹towych, jak i tekstur - choæ z regu³y czêœciej spotykan¹ praktyk¹ jest wykorzystywanie atlasów tekstur.\newline 

Mimo pewnych problemów, jakie niesie za sob¹ stosowanie tej techniki podczas pracy, wielu twórców stosuje j¹ w swoich projektach. Jest tak g³ównie dlatego, ¿e daje ona sporo korzyœci w kwestii potencjalnej wydajnoœci projektu. S¹ to przede wszystkim:
\begin{itemize}
	\item \textbf{Potencjalna oszczêdnoœæ pamiêci operacyjnej}
	\item \textbf{Mniej draw calli podczas renderowania sceny}
	\item \textbf{£atwiejszy dostêp do wielu tekstur jednoczeœnie}
\end{itemize}

Jak ju¿ zosta³o wspomniane wczeœniej, atlasowanie mo¿na stosowaæ zarówno dla modeli, jak i tekstur. Poni¿ej opisano w jaki sposób postêpuje siê zarówno w jednym, jak i drugim przypadku:
\begin{itemize}
	\item \textbf{Atlasy tekstur}
	\item \textbf{Atlasy modeli}
\end{itemize}

Wykorzystywanie atlasów wi¹¿e siê jednak z pewnymi utrudnieniami, z którymi nale¿y liczyæ siê podczas procesu produkcji.
\begin{itemize}
	\item \textbf{Du¿y rozmiar plików na repozytorium} - 
	\item \textbf{Dodatkowe nak³ady pracy przy rêcznym uk³adaniu atlasów} - 
\end{itemize}

\section{Wykorzystywanie mo¿liwoœci u¿ywanego silnika}
Równie wa¿ne, jak stosowanie uniwersalnych technik optymalizacji, jest zapoznanie siê z mo¿liwoœciami oferowanymi przez wybran¹ technologiê, na której tworzony jest projekt gry. Pozwala to nie tylko na uzyskanie lepszych wyników w kwestii wydajnoœci, ale tak¿e na poprawienie jakoœci samej grafiki wyœwietlanej na ekranie gracza. Poniewa¿ docelowym silnikiem, na której realizowano czêœæ praktyczn¹ tej pracy jest \textit{Unreal Engine 4}, to w tej czêœci przybli¿one zostan¹ cechy charakterystyczne dla tej technologii:
\begin{itemize}
	\item \textbf{Physically based rendering} - 
	\item \textbf{Maskowanie} - 
\end{itemize}
