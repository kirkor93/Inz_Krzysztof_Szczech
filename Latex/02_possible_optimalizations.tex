% !TeX encoding = windows-1250

\chapter{Mo¿liwe metody optymalizacji procesu produkcji modeli oraz tekstur}
\label{t:optimalizations}
Celem tego rozdzia³u jest przedstawienie istniej¹cych i wykorzystywanych w bran¿y gier komputerowych metod optymalizacji assetów trójwymiarowych. Ka¿da z opisywanych metod zawiera opis, potencjalne zyski id¹ce za jej zastosowaniem oraz przyk³ad u¿ycia w istniej¹cych produkcjach.

\section{Modularnoœæ modeli i tekstur}
Wykorzystywanie modu³ów przy tworzenia poziomów w grach komputerowych jest technik¹ bardzo szeroko stosowan¹ przez wspó³czesnych twórców. Ciê¿ko jest obecnie znaleŸæ produkcjê która nie korzysta³aby z zalet modularnoœci. \newline

Czym jest wspomniany proces? Jedna z najwiêkszych firm bran¿ komputerowej - Epic Games - definiuje go jako ''tworzenie du¿ej liczby wysokojakoœciowych fragmentów poziomu i wielokrotne u¿ywanie ich w inteligentny sposób''\cite{Investigation}. W praktyce wygl¹da to tak, ¿e wszelkie modele oraz tekstury tworzone s¹ tak, aby mo¿liwe by³o u³o¿enie jak najwiêkszej liczby kombinacji pasuj¹cych do siebie elementów. Dziêki temu ze stosunkowo niewielkiej liczby modu³ów, osoba zajmuj¹ca siê póŸniej kreacj¹ docelowych poziomów w silniku gry mo¿e doœæ niskim kosztem bardzo uatrakcyjniæ ich wygl¹d. Rodzi to jednak wiele wyzwañ przed artystami zajmuj¹cymi siê tworzeniem siatek wielok¹towych oraz rysowaniem i edycj¹ tekstur. Przyk³adem jest tu chocia¿by odpowiednia konfiguracja siatki wed³ug której uk³adane s¹ elementy w silniku (ang. grid).\cite{CreatingModularGameArt} Wiêcej o nich wspomnê w kolejnym rozdziale, w którym opiszê szczegó³y procesu twórczego. \newline

Bardzo wa¿nym pojêciem, które czêsto przewija siê przy okazji takiego podejœcia do procesu twórczego jest ''tiling'' (ang. tile - kafelek). W przypadku trójwymiarowych siatek wielok¹towych odnosi siê ono do tworzenia ich w taki sposób, aby postawione obok siebie dwa obiekty (na przyk³ad fragmenty œciany) wygl¹da³y jak jeden, spójny model. Analogicznie jest w przypadku tekstur - gdy u³o¿ymy taki obrazek obok siebie kilka razy, osoba ogl¹daj¹ca go nie mo¿e byæ w stanie zauwa¿yæ ³¹czeñ miêdzy instancjami (ale mo¿e spostrzec powtarzalnoœæ, jeœli powielimy go zbyt wiele razy). \newline Ponadto wyró¿niamy 2 rodzaje tilingu: 
\begin{itemize}
	\item jednokierunkowy - model lub tekstura mo¿e byæ uk³adana tylko w poziomie lub w pionie bez zauwa¿alnych szwów 
	\item dwukierunkowy - uk³adanie bez szwów jest mo¿liwe zarówno w poziomie, jak i w pionie
\end{itemize}
 Przyk³ady obiektów pierwszego i drugiego rodzaju znajdziemy na rysunkach 2.1 oraz 2.2.
 \begin{figure}[!ht]
 	\centering
 	\includegraphics[scale = 0.85]{figures/Wall_tileable}
 	\caption{Przyk³ad trójwymiarowego modelu (œciany) z jednokierunkowym tilingiem (Ÿród³o: opracowanie w³asne)}
 \end{figure}
 \begin{figure}[!ht]
 	\centering
 	\includegraphics[scale = 0.65]{figures/Floor_wooden_2}
 	\caption{Przyk³ad tekstury (pod³ogi) z dwukierunkowym tilingiem (Ÿród³o: opracowanie w³asne)}
 \end{figure}
 \newpage
 Mo¿emy wyró¿niæ dwa rodzaje zalet, które niesie za sob¹ modularne podejœcie do procesu tworzenia poziomów. Pierwsze z nich, to potencjalne korzyœci dla samego procesu. Przyk³adem tutaj s¹ miêdzy innymi:
 \begin{itemize}
 	\item W wiêkszoœci przypadków pozwala na skrócenie czasu potrzebnego na stworzenie poziomu, co pozwala na lepsze dopracowanie samych assetów.
 	\item Mo¿liwoœæ wprowadzania poprawek na elementach ju¿ u³o¿onych w docelowym silniku (pod warunkiem odpowiedniego zaprojektowania ich wczeœniej). Dziêki temu ludzie zajmuj¹cy siê projektowaniem poziomów do gier mog¹ rozpocz¹æ ich uk³adanie w silniku na bardzo wczesnym etapie produkcji. Przy odpowiednim ustawieniu punktu odniesienia w przestrzeni dla obiektów (ang. pivot point), obiekty mog¹ byæ ustawione w docelowym po³o¿eniu ju¿ na etapie wczesnych prototypów, by po jakimœ czasie zostaæ podmienione na finalne modele z teksturami bez dodatkowej ingerencji w pliki sceny.
 	\item Wielokrotne wykorzystanie tych samych modeli i tekstur wcale nie oznacza, ¿e poziomy w grze bêd¹ wygl¹da³y na nudne i powtarzalne. Przy odpowiednim wykorzystaniu oœwietlenia, projektanci s¹ w stanie uzyskiwaæ bardzo ciekawe efekty bez potrzeby tworzenia wielu assetów. T¹ sytuacjê mo¿emy zaobserwowaæ na rysunku 2.3, gdzie porównano ten sam fragment sceny przy ró¿nych ustawieniach oœwietlenia.
  	\begin{figure}[!ht]
 		\centering
  		\includegraphics[scale = 0.20]{figures/Using_light_to_differ_assets}
  		\caption{Wykorzystanie oœwietlenia w celu ukrycia faktu wykorzystania niewielkiej iloœci modeli (Ÿród³o: \cite{Investigation})}
 	\end{figure}
 \end{itemize}
 Dodatkowo, modularnoœæ pozwala na uzyskanie profitów w kwestii wydajnoœci projektu. To w du¿ej mierze z tego powodu zyska³a ona tak du¿¹ popularnoœæ wœród twórców gier komputerowych, gdy¿ dla uzyskania maksymalnego komfortu rozgrywki nale¿y jak najbardziej skróciæ czas renderingu pojedynczej klatki obrazu. \newline
 
 Pierwszym z nich jest potencjalna oszczêdnoœæ pamiêci karty graficznej. Jak to siê dzieje, ¿e mo¿emy uzyskaæ taki efekt? Otó¿, gdy chcemy by karta graficzna wyrenderowa³a nam klatkê obrazu, musimy najpierw zapewniæ jej wszystkie potrzebne do tego dane. Wœród nich znajdziemy chocia¿by: orientacjê w przestrzeni obiektów (oraz wierzcho³ków tych¿e obiektów), koordynaty teksturowania, pozycje œwiate³ oraz same tekstury. Wszystkie one musz¹ zostaæ skopiowane do wewnêtrznej pamiêci RAM karty graficznej. Jeœli scena bêdzie sk³adaæ siê z jednego, wielkiego modelu 3d, to bêdzie on musia³ byæ w ca³oœci wczytany do pamiêci w celu jego dalszego wykorzystania w procesie renderingu. Stworzenie modu³ów, które nastêpnie zostaj¹ wielokrotnie instancjonowane w scenie pozwala na nieco inne potraktowanie danych przesy³anych do karty. Sam model zostaje skopiowany do pamiêci tylko raz, a dane dotycz¹ce transformacji ka¿dej z instancji (pozycji, rotacji i skali) s¹ przesy³ane niezale¿nie od nich. Pozwala to na potencjalne oszczêdnoœci w szczególnoœci, gdy wielokrotnie wykorzystujemy dany modu³. \cite{GPUGems2} \newline
 
 Kolejnym argumentem przemawiaj¹cym za stosowaniem modu³ów jest zwiêkszenie przenoœnoœci i uniwersalnoœci samych assetów. Analogicznie do poprzedniego przyk³adu - je¿eli scena zosta³a stworzona jako jeden, wielki model to aby stworzyæ nieco zmienion¹ jej wersjê nale¿y skopiowaæ ca³oœæ, wprowadziæ zmiany, a na koniec wyeksportowaæ now¹ wersjê (równie¿ jako jeden, du¿y obiekt). Stwarza to przynajmniej trzy problemy:
 \begin{itemize}
 	\item Ka¿da zmiana uk³adu sceny wymaga ingerencji w pliki Ÿród³owe modeli 3d oraz ich ponowny eksport do silnika.
 	\item Nie jest mo¿liwe ponowne wykorzystanie w prosty sposób fragmentów sceny w innych projektach lub nawet w tym samym projekcie i kolejnych poziomach. Ka¿dorazowe wykorzystanie elementów modelu wymaga ingerencji w pliki Ÿród³owe oraz wyodrêbnienie ich od reszty siatki.
 	\item Wspomniana ju¿ wczeœniej pamiêæ karty graficznej zostaje niepotrzebnie zapisana nadmiarowymi danymi, które mog³yby zostaæ zast¹pione instancjonowaniem.
 \end{itemize}
 Wszystkie trzy problemy eliminuje zaprojektowanie i stworzenie modu³ów, z których dopiero póŸniej s¹ budowane docelowe poziomy w zale¿noœci od aktualnych potrzeb projektanta. Dodatkowo pozwala równie¿ na doœæ wygodne oddzielenie pracy projektanta poziomów od artysty tworz¹cego modele i tekstury.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale = 0.20]{figures/AssetsPack}
	\caption{Przyk³adowa paczka modularnych modeli (Ÿród³o: \cite{ModularPack})}
\end{figure}
\section{Atlasowanie}
Atlasowanie jest procesem maj¹cym na celu zebranie wielu niekoniecznie powi¹zanych ze sob¹ assetów w jedn¹ ca³oœæ oraz przechowywanie ich w jednym, du¿ym pliku. Mo¿liwe jest stosowanie go zarówno w odniesieniu do siatek wielok¹towych, jak i tekstur - choæ z regu³y czêœciej spotykan¹ praktyk¹ jest wykorzystywanie tego drugiego rodzaju atlasów.\newline 

Mimo pewnych problemów, jakie niesie za sob¹ stosowanie tej techniki podczas pracy, wielu twórców stosuje j¹ w swoich projektach. Jest tak g³ównie dlatego, ¿e daje ona wymierne korzyœci w kwestii wydajnoœci projektu. S¹ to przede wszystkim:
\begin{itemize}
	\item \textbf{Potencjalna oszczêdnoœæ pamiêci operacyjnej} \newline
	Pliki zapisywane na dysku twardym komputera w wielu wypadkach zawieraj¹ w sobie wiele nadmiarowych danych, które sprawiaj¹, ¿e zajmuj¹ czasem znacznie wiêcej miejsca, ni¿ ¿yczy³by sobie ich autor. W przypadku plików wideo, oprócz zakodowanego obrazu i dŸwiêku, znaleŸæ mo¿na równie¿ dane o ich autorze, czy te¿ roku utworzenia klipu.\cite{VideoMetadata} Pliki graficzne mog¹ natomiast za³¹czaæ miejsce ich wykonania (na przyk³ad w przypadku zdjêæ czêst¹ praktyk¹ jest zamieszczanie danych zebranych z modu³ów GPS aparatów). Dodatkowo - ka¿dy plik zawiera w sobie równie¿ nag³ówek, który dodatkowo zwiêksza jego rozmiar. Zebranie kilku tekstur lub modeli pozwala na wyeliminowanie wielokrotnego zapisywania tego typu danych, co przy wiêkszej skali projektu pozwala na wymierne zmniejszenie zajmowanego przez nie miejsca.
	\item \textbf{Skrócenie czasu u¿ycia dysku twardego} \newline
	Wczytywanie zasobów z dysku twardego komputera jest procesem bardzo czasoch³onnym. Jest to szczególnie uci¹¿liwe, jeœli u¿ywany jest dysk starego typu (HDD), w którym wystêpuj¹ jeszcze ruchome, mechaniczne czêœci, które dodatkowo spowalniaj¹ ten proces. Podczas uruchamiania gry komputerowej ma to bardzo du¿y wp³yw na czasy wczytywania poszczególnych poziomów. W³aœnie dlatego zminimalizowanie liczby poszukiwañ plików jest kluczowe w procesie tworzenia gier komputerowych. Krótszy czas ogl¹dania ekranów ³adowania mo¿e mieæ równie¿ pozytywny wp³yw na imersjê gracza - krótsze przerwy od rozgrywki pozwalaj¹ mu lepiej wczuæ siê w ni¹.
	\item \textbf{Mniej pakietów, które musi obs³u¿yæ procesor podczas renderowania sceny} \newline
	Ka¿dy obiekt, tekstura, czy te¿ mechanika u¿yta w grze komputerowej jest potencjalnym nowym pakietem, który musi zostaæ przetworzony przez procesor na którymœ z etapów renderingu. Wspó³czesne procesory s¹ w stanie obs³u¿yæ nawet 100000 takich pakietów na sekundê. \cite{GPUGems2}\newline 
	
	Co prawda obecnie zaimplementowane technologie s¹ w stanie automatycznie ³¹czyæ luŸno rozrzucone assety w takie pakiety, jednak zrobienie tego w³asnorêcznie gwarantuje otrzymanie dok³adnie tylu pakietów, ile jest oczekiwane przez twórcê. Dodatkowo, jeœli ich liczba bêdzie zbyt du¿a, to mo¿e mieæ ona wp³yw na tempo renderowania kolejnych klatek obrazu przez kartê graficzn¹, gdy¿ procesor nie bêdzie nad¹¿a³ z ich przetwarzaniem i kopiowaniem do pamiêci GPU. 
	\item \textbf{Mo¿liwoœæ tworzenia niewymiarowych tekstur} \newline
	Wspó³czesne karty graficzne s¹ zaprojektowane w taki sposób, ¿e stawiaj¹ przed teksturami jedno, bardzo wa¿ne wymaganie: ich wymiary musz¹ byæ liczbami, które s¹ wynikiem podniesienia cyfry 2 do potêgi naturalnej. Stawia to wiele ograniczeñ przed twórcami, którzy musz¹ pamiêtaæ o tej zasadzie podczas teksturowania stworzonych przez siebie obiektów i przez to czêsto marnuj¹ wiele miejsca obrazu, który zwyczajnie by³ zbyt du¿y dla tworzonego modelu. Ten problem eliminuje wykorzystanie atlasowania. Po zebraniu wielu tekstur razem ich rozmiar przestaje mieæ znaczenie - wa¿ne s¹ tylko wymiary samego atlasu, w którym s¹ przechowywane. Przyk³adowo: w atlasie 1024 na 1024 pikseli (spe³niaj¹cym wy¿ej wspomniane wymogi) po odpowiednim jego rozplanowaniu mo¿na umieœciæ dowoln¹ iloœæ obrazów o dowolnej wielkoœci.
\end{itemize}

Jak ju¿ zosta³o wspomniane wczeœniej, atlasowanie mo¿na stosowaæ zarówno dla siatek wielok¹towych, jak i tekstur. Poni¿ej opisano w jaki sposób postêpuje siê zarówno w jednym, jak i drugim przypadku:
\begin{itemize}
	\item \textbf{Atlasy modeli} \newline
	Zebranie modeli w atlas polega na ich wspólnym wyeksportowania do jednego pliku (na przyk³ad w formacie .fbx), zamiast przenoszenia ka¿dego z nich oddzielnie w systemie jedna siatka w jednym pliku. Wiêkszoœæ wspó³czesnych silników, w których tworzone s¹ gry komputerowe potrafi wydzielaæ sk³adowe tak skonstruowanych atlasów i umo¿liwia traktowanie ich, jakby ka¿dy model pochodzi³ z oddzielnego pliku.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale = 1.0]{figures/Unity_models}
	\caption{Przyk³ad pliku zawieraj¹cego kilka siatek zaimportowanego do silnika Unity (Ÿród³o: opracowanie w³asne)}
\end{figure}
	\item \textbf{Atlasy tekstur} \newline
	Znacznie czêstsz¹ praktyk¹, ni¿ atlasowanie siatek wielok¹towych jest wykorzystywanie tej techniki dla tekstur. Mo¿liwe jest rêczne rozmieszczanie poszczególnych obrazków w atlasie dla maksymalnej kontroli nad procesem lub u¿ycie specjalnych programów, które automatyzuj¹ i przyœpieszaj¹ proces. Jednak opieraj¹c siê na algorytmach nale¿y pamiêtaæ, ¿e potrafi¹ one ca³kowicie zmieniæ aran¿acjê atlasu i spowodowaæ koniecznoœæ zmian w rozk³adzie koordynatów UV modeli, które je wykorzystuj¹.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale = 0.50]{figures/Texture_atlas}
	\caption{Z³o¿enie dwóch tekstur w atlas (Ÿród³o: \cite{Investigation})}
\end{figure}
\end{itemize}

Wykorzystywanie atlasów wi¹¿e siê równie¿ z pewnymi utrudnieniami, z którymi nale¿y liczyæ siê podczas procesu produkcji. W szczególnoœci mo¿emy wyró¿niæ tutaj:
\begin{itemize}
	\item \textbf{Du¿y rozmiar plików na repozytorium}. \newline
	Jeœli projekt jest przechowywany na repozytorium, wysy³anie nowych atlasów (w szczególnoœci tekstur) mo¿e byæ uci¹¿liwe lub czasami nawet niemo¿liwe poprzez ograniczenia technologiczne narzucone przez serwisy hostingowe. Przyk³adowo: serwis \textit{github.com} dla darmowych repozytoriów nie zezwala na umieszczanie w nich plików wiêkszych ni¿ 100 MB. Jeœli w projekcie wykorzystane bêd¹ atlasy w rozdzielczoœci przekraczaj¹cej 4096 na 4096 pikseli oraz zapisywane w formatach nie implementuj¹cych kompresji, to rozmiar pliku ³atwo mo¿e przekroczyæ t¹ wartoœæ, przez co niemo¿liwe stanie siê udostêpnienie go reszcie zespo³u pracuj¹cego nad projektem.
	\item \textbf{Dodatkowe nak³ady pracy przy rêcznym uk³adaniu atlasów}. \newline
	Automatyczne skrypty pozwalaj¹ce na kreowanie atlasów maj¹ wiele plusów, które pozwalaj¹ na usprawnienie pracy zespo³u grafików. Jednak w wielu przypadkach konieczne jest wykonanie tej pracy rêcznie i - co za tym idzie - borykanie siê z trudnoœciami manualnej obróbki obrazów. Jest to czasoch³onne, gdy¿ zazwyczaj wymagane jest stworzenie kilku lub nawet - w bardzo du¿ych projektach - kilkunastu atlasów. Dodatkowo zwykle dla ka¿dego modelu stosuje siê minimum trzy podstawowe mapy wp³ywaj¹ce na wygl¹d w silniku: diffuse (w której znajduj¹ siê informacje dotycz¹ce reakcji na œwiat³o rozproszone), normal (zawieraj¹c¹ wektory normalnych zakodowane w postaci pikseli) oraz specular / glow (która ma w sobie informacje o œwietle odbitym bezpoœrednio od powierzchni danego modelu). Z tego te¿ powodu warto spróbowaæ wdro¿yæ rozwi¹zania automatyzuj¹ce proces - szczególnie podczas pracy przy wiêkszych projektach.
\end{itemize}

\section{Wykorzystywanie mo¿liwoœci u¿ywanego silnika}
Równie wa¿ne, jak stosowanie uniwersalnych technik optymalizacji, jest zapoznanie siê z mo¿liwoœciami oferowanymi przez wybran¹ technologiê, na której tworzony jest projekt gry. Pozwala to nie tylko na uzyskanie lepszych wyników w kwestii wydajnoœci, ale tak¿e na poprawienie jakoœci samej grafiki wyœwietlanej na monitorze gracza. Poniewa¿ docelowym silnikiem, na której realizowano czêœæ praktyczn¹ tej pracy jest \textit{Unreal Engine 4}, to w tej czêœci przybli¿one zostan¹ cechy charakterystyczne dla tej technologii:
\begin{itemize}
	\item \textbf{Physically based rendering} \newline
	Rendering bazuj¹cy na rzeczywistych zjawiskach fizycznych jest czymœ, co od niedawna zaczyna podbijaæ œwiat gier komputerowych. Dzieje siê tak, poniewa¿ rozwój technologii od kilku lat zacz¹³ pozwalaæ na renderowanie obrazu tworzonego w ten sposób w czasie akceptowalnym dla graczy. Najnowsze wersje silników - takie, jak wspomniany wczeœniej \textit{Unreal Engine 4}, czy te¿ \textit{Unity 5} - pozwalaj¹ twórcom wykorzystywaæ zalety physycally based renderingu. \newline
	
	Czym w³aœciwie on jest? Wed³ug dokumentacji udostêpnionej przez twórców silnika \textit{Unreal Engine 4}: ''rendering oparty o fizykê to taki, który oblicza w przybli¿eniu to, jak œwiat³o dzia³a na dan¹ powierzchniê zamiast szacowaæ jego zachowanie w oparciu o ludzkie domys³y''.\cite{PBR} W praktyce oznacza to, i¿ PBR oblicza cieniowanie sceny na podstawie modelów matematycznych maj¹cych swoje odzwierciedlenie w œwiecie rzeczywistym (w pewnym przybli¿eniu). Wczeœniej stosowano prostsze modele, które nie mia³y zbyt wiele wspólnego z rzeczywistym zachowaniem œwiat³a, ale jednoczeœnie wymaga³y znacznie mniejszej mocy obliczeniowej. Ich przyk³adami s¹ chocia¿by:
	\begin{itemize}
		\item Model cieniowania Gourauda
		\item Model cieniowania Phonga
		\item Model cieniowania Phonga-Blinna
		\item Model cieniowania Lamberta
	\end{itemize}
	\begin{figure}[!ht]
		\centering
		\includegraphics[scale = 0.60]{figures/PBR}
		\caption{Przyk³ad obiektów wyrenderowanych dziêki Physycally Based Rendering w silniku \textit{Unreal Engine 4} (Ÿród³o: \cite{PBR})}
	\end{figure}
	Wykorzystanie PBR w projektach pozwala na uzyskiwanie bardzo realistycznych efektów, które nieraz przypominaj¹ rendery wizualizacji lub nawet zdjêcia.
	\item \textbf{Maskowanie} \newline
	Maskowanie jest technik¹ czêsto stosowan¹ podczas tworzenia dwuwymiarowych ilustracji, czy nawet animacji. Ma ona na celu zakrycie pewnych elementów jednego obrazka (lub te¿ warstwy w przypadku ilustracji sk³adaj¹cej siê z wiêcej ni¿ jednej z nich) w celu ukazania fragmentów innego, znajduj¹cego siê pod nim. Dziêki maskowaniu mo¿liwe jest uzyskiwanie ciekawych kompozycji wielu - czêsto niezwi¹zanych ze sob¹ - obrazów. \newline
	
	\textit{Unreal Engine 4} implementuje mechanizmy pozwalaj¹ce na wykorzystywanie masek w celu ³¹czenia ze sob¹ tekstur. Mo¿na to robiæ na wiêcej ni¿ jeden sposób, gdy¿ silnik oferuje implementacje wielu funkcji matematycznych, które pozwalaj¹ na uzyskanie ró¿nych efektów w zale¿noœci od aktualnych potrzeb twórcy. Co wiêcej - maskowanie pozwala nieraz unikn¹æ tworzenia wielu dodatkowych tekstur, które zajmowa³yby dodatkowe miejsce w pamiêci RAM karty graficznej. \newline
	
	Na rysunku 2.8 przedstawiono jedno z mo¿liwych zastosowañ masek w silniku. Tekstura krzy¿a zosta³a dodatkowo wzbogacona o emisjê ¿ó³tego œwiat³a w miejscach, gdzie jest ona przeŸroczysta (kana³ alfa przyjmuje wartoœæ zbli¿on¹ do zera). Do uzyskania efektu nie wykorzystano ¿adnych dodatkowych tekstur emisji, a jedynie prost¹ funkcjê matematyczn¹ - interpolacjê liniow¹, która zwraca³a coraz bardziej intensywny kolor ¿ó³ty wraz ze spadkiem wartoœci kana³u alfa tekstury, a nastêpnie by³ on wykorzystywany jako tekstura emisji dla stworzonego materia³u. Finalny efekt jest mo¿liwy do zaobserwowania w okienku podgl¹du edytora materia³ów w lewym górnym rogu obrazka.
	\begin{figure}[!ht]
		\centering
		\includegraphics[scale = 0.45]{figures/UE4_masking}
		\caption{Przyk³adowe wykorzystanie materia³u wykorzystuj¹cego maskowanie w \textit{Unreal Engine 4} (Ÿród³o: opracowanie w³asne)}
	\end{figure}
\end{itemize}
